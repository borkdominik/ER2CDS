/******************************************************************************
 * This file was generated by langium-cli 2.1.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import type { AstNode, Reference, ReferenceInfo, TypeMetaData } from 'langium';
import { AbstractAstReflection } from 'langium';

export const ER2CDSTerminals = {
    ID: /[_a-zA-Z\/][\w_]*/,
    INT: /[0-9]+/,
    STRING: /[A-Za-z]+/,
    WS: /\s+/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};

export type AttributeType = 'key';

export type CardinalityType = '0..N' | '1' | '1..N';

export type KEY = 'key';

export function isKEY(item: unknown): item is KEY {
    return item === 'key';
}

export type ONE = '1';

export function isONE(item: unknown): item is ONE {
    return item === '1';
}

export type ONE_MANY = '1..N';

export function isONE_MANY(item: unknown): item is ONE_MANY {
    return item === '1..N';
}

export type ZERO_MANY = '0..N';

export function isZERO_MANY(item: unknown): item is ZERO_MANY {
    return item === '0..N';
}

export interface Attribute extends AstNode {
    readonly $container: Entity;
    readonly $type: 'Attribute';
    datatype?: DataType
    name: string
    type?: AttributeType
}

export const Attribute = 'Attribute';

export function isAttribute(item: unknown): item is Attribute {
    return reflection.isInstance(item, Attribute);
}

export interface DataType extends AstNode {
    readonly $container: Attribute;
    readonly $type: 'DataType';
    d?: number
    size?: number
    type: string
}

export const DataType = 'DataType';

export function isDataType(item: unknown): item is DataType {
    return reflection.isInstance(item, DataType);
}

export interface Entity extends AstNode {
    readonly $container: ER2CDS;
    readonly $type: 'Entity';
    attributes: Array<Attribute>
    name: string
}

export const Entity = 'Entity';

export function isEntity(item: unknown): item is Entity {
    return reflection.isInstance(item, Entity);
}

export interface ER2CDS extends AstNode {
    readonly $type: 'ER2CDS';
    entities: Array<Entity>
    name: string
    relationships: Array<Relationship>
}

export const ER2CDS = 'ER2CDS';

export function isER2CDS(item: unknown): item is ER2CDS {
    return reflection.isInstance(item, ER2CDS);
}

export interface Relationship extends AstNode {
    readonly $container: ER2CDS;
    readonly $type: 'Relationship';
    attributes: Array<RelationshipAttribute>
    first?: RelationshipEntity
    name: string
    second?: RelationshipEntity
}

export const Relationship = 'Relationship';

export function isRelationship(item: unknown): item is Relationship {
    return reflection.isInstance(item, Relationship);
}

export interface RelationshipAttribute extends AstNode {
    readonly $container: Relationship;
    readonly $type: 'RelationshipAttribute';
    firstAttribute: Reference<Attribute>
    secondAttribute: Reference<Attribute>
}

export const RelationshipAttribute = 'RelationshipAttribute';

export function isRelationshipAttribute(item: unknown): item is RelationshipAttribute {
    return reflection.isInstance(item, RelationshipAttribute);
}

export interface RelationshipEntity extends AstNode {
    readonly $container: Relationship;
    readonly $type: 'RelationshipEntity';
    cardinality?: CardinalityType
    role?: string
    target: Reference<Entity>
}

export const RelationshipEntity = 'RelationshipEntity';

export function isRelationshipEntity(item: unknown): item is RelationshipEntity {
    return reflection.isInstance(item, RelationshipEntity);
}

export type ER2CDSAstType = {
    Attribute: Attribute
    DataType: DataType
    ER2CDS: ER2CDS
    Entity: Entity
    Relationship: Relationship
    RelationshipAttribute: RelationshipAttribute
    RelationshipEntity: RelationshipEntity
}

export class ER2CDSAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['Attribute', 'DataType', 'ER2CDS', 'Entity', 'Relationship', 'RelationshipAttribute', 'RelationshipEntity'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'RelationshipAttribute:firstAttribute':
            case 'RelationshipAttribute:secondAttribute': {
                return Attribute;
            }
            case 'RelationshipEntity:target': {
                return Entity;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'Entity': {
                return {
                    name: 'Entity',
                    mandatory: [
                        { name: 'attributes', type: 'array' }
                    ]
                };
            }
            case 'ER2CDS': {
                return {
                    name: 'ER2CDS',
                    mandatory: [
                        { name: 'entities', type: 'array' },
                        { name: 'relationships', type: 'array' }
                    ]
                };
            }
            case 'Relationship': {
                return {
                    name: 'Relationship',
                    mandatory: [
                        { name: 'attributes', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new ER2CDSAstReflection();
