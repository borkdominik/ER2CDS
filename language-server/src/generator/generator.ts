import { LangiumServices, URI, expandToString } from 'langium';
import { createER2CDSServices } from '../er2cds-module.js';
import { Attribute, ER2CDS, Entity, Relationship, RelationshipAttribute } from '../generated/ast.js';
import { ER2CDSFileSystem } from '../er2cds-file-system-provider.js';

export async function generateCDS(fileName: string): Promise<void> {
    const fileUri = URI.parse(fileName);

    const services = createER2CDSServices(ER2CDSFileSystem).ER2CDS;

    const model = await extractAstFromFile<ER2CDS>(fileUri, services);
    const sourceCode = generateSourceCode(model);

    const fileNameWithExtension = fileUri.fsPath.substring(fileUri.fsPath.lastIndexOf('/') + 1, fileUri.fsPath.length);
    const fileNameWithoutExtension = fileNameWithExtension.substring(0, fileNameWithExtension.lastIndexOf('.'));

    const generatedFileName = fileNameWithoutExtension + '-generated.abapcds';
    const generatedFilePath = fileUri.fsPath.substring(0, fileUri.fsPath.lastIndexOf('/')) + '/' + generatedFileName;

    ER2CDSFileSystem.fileSystemProvider().writeFile(URI.parse(generatedFilePath), sourceCode);

    return Promise.resolve();
}

async function extractAstFromFile<T extends ER2CDS>(fileUri: URI, services: LangiumServices): Promise<T> {
    const document = services.shared.workspace.LangiumDocumentFactory.create(fileUri);
    await services.shared.workspace.DocumentBuilder.build([document], { validation: true });

    return document.parseResult?.value as T;
}



function generateSourceCode(model: ER2CDS): string {
    return expandToString`
        ${generateHeaderAnnotations(model)}
        ${generateHeader(model)}
            ${generateFromClause(model)}
            ${generateInnerJoins(model)}
        {
            ${generateKeyAttributes(model)}${model.entities.find(e => e.attributes.find(a => a.type === 'key')) && model.entities.find(e => e.attributes.find(a => a.type !== 'key')) ? ',' : ''}
            ${generateAttributes(model)}
        }
    `;
}

function generateHeaderAnnotations(model: ER2CDS): string {
    return expandToString`
        @AbapCatalog.viewEnhancementCategory: [#NONE]
        @AccessControl.authorizationCheck: #CHECK
        @EndUserText.label: 'Generated by ER2CDS'
        @Metadata.ignorePropagatedAnnotations: true
        @ObjectModel.usageType:{
            serviceQuality: #X,
            sizeCategory: #S,
            dataClass: #MIXED
        }
    `;
}

function generateHeader(model: ER2CDS): string {
    return expandToString`
        define view entity ${model.name} as select
    `;
}

function generateFromClause(model: ER2CDS): string {
    if (model.entities && model.entities.length > 0) {
        return expandToString`
            from ${model.relationships[0].first?.target.ref?.name}
        `;
    }

    return '';
}

function generateInnerJoins(model: ER2CDS): string {
    if (model.relationships) {
        return model.relationships.map(r => {
            let join = '';

            if (r.first?.cardinality === '1' && r.second?.cardinality === '1') {
                join = generateInnerJoin(model, r)

            } else if (r.first?.cardinality === '1' && r.second?.cardinality === 'N') {
                join = generateLeftJoin(model, r)

            } else {
                join = generateInnerJoin(model, r);
            }

            return join;
        }).join('\n');
    }

    return '';
}

function generateInnerJoin(model: ER2CDS, relationship: Relationship): string {
    if (model.entities && model.entities.length > 0) {
        return expandToString`
                inner join ${relationship.second?.target.ref?.name} on ${generateJoinClause(relationship, relationship.attributes)}
            `;
    }

    return '';
}

function generateLeftJoin(model: ER2CDS, relationship: Relationship): string {
    if (model.entities && model.entities.length > 0) {
        return expandToString`
                left join ${relationship.second?.target.ref?.name} on ${generateJoinClause(relationship, relationship.attributes)}
            `;
    }

    return '';
}

function generateJoinClause(relationship: Relationship, attributes: RelationshipAttribute[]): string {
    let joinClause = '';

    joinClause = attributes.map(a => {
        return expandToString`
            ${relationship.first?.target.ref?.name}.${a.firstAttribute.ref?.name} = ${relationship.second?.target.ref?.name}.${a.secondAttribute.ref?.name}
        `
    }).join(' and ');

    return joinClause;
}

function generateKeyAttributes(model: ER2CDS) {
    if (model.entities) {
        let attributes: string[] = [];

        model.entities.forEach(e => {
            const keyFields = e.attributes.filter(a => a.type === 'key');

            if (keyFields.length > 0)
                attributes.push(keyFields.map(a => generateAttribute(e, a)).join(',\n'));
        });

        return attributes.join(',\n');
    }

    return '';
}

function generateAttributes(model: ER2CDS) {
    if (model.entities) {
        let attributes: string[] = [];

        model.entities.forEach(e => {
            const nonKeyFields = e.attributes.filter(a => a.type !== 'key');

            if (nonKeyFields.length > 0)
                attributes.push(nonKeyFields.map(a => generateAttribute(e, a)).join(',\n'));
        });

        return attributes.join(',\n');
    }

    return '';
}

function generateAttribute(entity: Entity, attribute: Attribute) {
    return expandToString`
        ${attribute.type === 'key' ? 'key' : ''} ${entity.name}.${attribute.name} as ${entity.name}_${attribute.name}
    `;
}