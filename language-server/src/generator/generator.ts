import { URI, expandToString } from 'langium';
import { createER2CDSServices } from '../er2cds-module.js';
import { Attribute, ER2CDS, Entity, Relationship, RelationshipJoinClause } from '../generated/ast.js';
import { ER2CDSFileSystem } from '../er2cds-file-system-provider.js';
import { MessageType } from 'vscode-languageserver-protocol';
import { connection } from '../server.js';

export async function generateCDS(fileName: string): Promise<void> {
    const fileUri = URI.parse(fileName);

    const services = createER2CDSServices(ER2CDSFileSystem).ER2CDS;

    const document = services.shared.workspace.LangiumDocumentFactory.create(fileUri);
    await services.shared.workspace.DocumentBuilder.build([document], { validation: true })

    const parseResult = document.parseResult;
    if ((parseResult.parserErrors && parseResult.parserErrors.length > 0) || (parseResult.lexerErrors && parseResult.lexerErrors.length > 0)) {
        connection.sendNotification('window/showMessage', {
            type: MessageType.Error,
            message: 'Model contains errors. CDS cannot be generated.'
        });
        return;
    }

    const diagnostics = await services.validation.DocumentValidator.validateDocument(document);
    if (diagnostics.some(d => d.severity === 1)) {
        connection.sendNotification('window/showMessage', {
            type: MessageType.Error,
            message: 'Model contains errors. CDS cannot be generated.'
        });
        return;
    }

    const sourceCode = generateSourceCode(parseResult.value as ER2CDS);

    const fileNameWithExtension = fileUri.fsPath.substring(fileUri.fsPath.lastIndexOf('/') + 1, fileUri.fsPath.length);
    const fileNameWithoutExtension = fileNameWithExtension.substring(0, fileNameWithExtension.lastIndexOf('.'));

    const generatedFileName = fileNameWithoutExtension + '-generated.abapcds';
    const generatedFilePath = fileUri.fsPath.substring(0, fileUri.fsPath.lastIndexOf('/')) + '/' + generatedFileName;

    ER2CDSFileSystem.fileSystemProvider().writeFile(URI.parse(generatedFilePath), sourceCode);

    return Promise.resolve();
}

function generateSourceCode(model: ER2CDS): string {
    model.relationships.sort((r1, r2) => {
        if (r1.joinOrder && r2.joinOrder)
            return r1.joinOrder - r2.joinOrder;

        if (r1.joinOrder)
            return -1;

        if (r2.joinOrder)
            return 1;

        return 0;
    });

    return expandToString`
        ${generateHeaderAnnotations(model)}
        ${generateHeader(model)}
            ${generateFromClause(model)}
            ${generateJoins(model)}
        {
            ${generateKeyAttributes(model)}${model.entities.find(e => e.attributes.find(a => a.type === 'key')) && model.entities.find(e => e.attributes.find(a => a.type !== 'key')) ? ',' : ''}
            ${generateAttributes(model)}
        }
    `;
}

function generateHeaderAnnotations(model: ER2CDS): string {
    return expandToString`
        @AbapCatalog.viewEnhancementCategory: [#NONE]
        @AccessControl.authorizationCheck: #CHECK
        @EndUserText.label: 'Generated by ER2CDS'
        @Metadata.ignorePropagatedAnnotations: true
        @ObjectModel.usageType:{
            serviceQuality: #X,
            sizeCategory: #S,
            dataClass: #MIXED
        }
    `;
}

function generateHeader(model: ER2CDS): string {
    return expandToString`
        define view entity ${model.name} as select
    `;
}

function generateFromClause(model: ER2CDS): string {
    if (model.relationships && model.relationships.length > 0) {
        return expandToString`
            from ${model.relationships[0].source?.target.ref?.name}
        `;
    }

    return '';
}

function generateJoins(model: ER2CDS): string {
    if (model.relationships) {
        return model.relationships.map(r => {
            let join = '';

            if (r.source?.cardinality === '1' && r.target?.cardinality === '1') {
                join = generateInnerJoin(model, r);

            } else if (r.source?.cardinality === '1' && r.target?.cardinality === '0..N') {
                join = generateLeftJoin(model, r);

            } else if (r.source?.cardinality === '0..N' && r.target?.cardinality === '1') {
                join = generateRightJoin(model, r);

            } else if (r.source?.cardinality === '0..N' && r.target?.cardinality === '0..N') {
                join = generateFullJoin(model, r);

            } else {
                join = generateInnerJoin(model, r);

            }

            return join;
        }).join('\n');
    }

    return '';
}

function generateInnerJoin(model: ER2CDS, relationship: Relationship): string {
    if (model.entities && model.entities.length > 0) {
        return expandToString`
                inner join ${relationship.target?.target.ref?.name} on ${generateJoinClause(relationship, relationship.joinClauses)}
            `;
    }

    return '';
}

function generateLeftJoin(model: ER2CDS, relationship: Relationship): string {
    if (model.entities && model.entities.length > 0) {
        return expandToString`
                left outer join ${relationship.target?.target.ref?.name} on ${generateJoinClause(relationship, relationship.joinClauses)}
            `;
    }

    return '';
}

function generateRightJoin(model: ER2CDS, relationship: Relationship): string {
    if (model.entities && model.entities.length > 0) {
        return expandToString`
                right outer join ${relationship.target?.target.ref?.name} on ${generateJoinClause(relationship, relationship.joinClauses)}
            `;
    }

    return '';
}

function generateFullJoin(model: ER2CDS, relationship: Relationship): string {
    if (model.entities && model.entities.length > 0) {
        return expandToString`
                full join ${relationship.target?.target.ref?.name} on ${generateJoinClause(relationship, relationship.joinClauses)}
            `;
    }

    return '';
}

function generateJoinClause(relationship: Relationship, joinClauses: RelationshipJoinClause[]): string {
    let joinClause = '';

    joinClause = joinClauses.map(jc => {
        return expandToString`
            ${relationship.source?.target.ref?.name}.${jc.firstAttribute.ref?.name} = ${relationship.target?.target.ref?.name}.${jc.secondAttribute.ref?.name}
        `
    }).join(' and ');

    return joinClause;
}

function generateKeyAttributes(model: ER2CDS) {
    if (model.entities) {
        let attributes: string[] = [];

        model.entities.forEach(e => {
            const keyFields = e.attributes.filter(a => a.type === 'key');

            if (keyFields.length > 0)
                attributes.push(keyFields.map(a => generateAttribute(e, a)).join(',\n'));
        });

        return attributes.join(',\n');
    }

    return '';
}

function generateAttributes(model: ER2CDS) {
    if (model.entities) {
        let attributes: string[] = [];

        model.entities.forEach(e => {
            const nonKeyFields = e.attributes.filter(a => a.type !== 'key');

            if (nonKeyFields.length > 0)
                attributes.push(nonKeyFields.map(a => generateAttribute(e, a)).join(',\n'));
        });

        return attributes.join(',\n');
    }

    return '';
}

function generateAttribute(entity: Entity, attribute: Attribute) {
    return expandToString`
        ${attribute.type === 'key' ? 'key' : ''} ${entity.name}.${attribute.name} as ${entity.name}_${attribute.name}
    `;
}