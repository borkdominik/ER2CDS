import { LangiumServices, URI, expandToString } from 'langium';
import { createER2CDSServices } from '../er2cds-module.js';
import { Attribute, ER2CDS, Entity, Relationship, RelationshipEntity } from '../generated/ast.js';
import { ER2CDSFileSystem } from '../er2cds-file-system-provider.js';

export async function generateCDS(fileName: string): Promise<void> {
    const fileUri = URI.parse(fileName);

    const services = createER2CDSServices(ER2CDSFileSystem).ER2CDS;

    const model = await extractAstFromFile<ER2CDS>(fileUri, services);
    const sourceCode = generateSourceCode(model);

    const fileNameWithExtension = fileUri.fsPath.substring(fileUri.fsPath.lastIndexOf('/') + 1, fileUri.fsPath.length);
    const fileNameWithoutExtension = fileNameWithExtension.substring(0, fileNameWithExtension.lastIndexOf('.'));

    const generatedFileName = fileNameWithoutExtension + '-generated.abapcds';
    const generatedFilePath = fileUri.fsPath.substring(0, fileUri.fsPath.lastIndexOf('/')) + '/' + generatedFileName;

    ER2CDSFileSystem.fileSystemProvider().writeFile(URI.parse(generatedFilePath), sourceCode);

    return Promise.resolve();
}

async function extractAstFromFile<T extends ER2CDS>(fileUri: URI, services: LangiumServices): Promise<T> {
    const document = services.shared.workspace.LangiumDocumentFactory.create(fileUri);
    await services.shared.workspace.DocumentBuilder.build([document], { validation: true });

    return document.parseResult?.value as T;
}

function generateSourceCode(model: ER2CDS): string {
    return expandToString`
        ${generateHeaderAnnotations(model)}
        ${generateHeader(model)}
            ${generateFromClause(model)}
            ${generateInnerJoins(model)}
        {
            ${generateAttributes(model)}
        }
    `;
}

function generateHeaderAnnotations(model: ER2CDS): string {
    return expandToString`
        @AccessControl.authorizationCheck: #NOT_REQUIRED
        @EndUserText.label: 'Generated by ER2CDS'
    `;
}

function generateHeader(model: ER2CDS): string {
    return expandToString`
        define view entity ${model.name} as select
    `;
}

function generateFromClause(model: ER2CDS): string {
    if (model.entities && model.entities.length > 0) {
        return expandToString`
            from ${model.entities[0].name}
        `;
    }

    return '';
}

function generateInnerJoins(model: ER2CDS): string {
    if (model.relationships) {
        return model.relationships.map(r => generateInnerJoin(model, r)).join('\n');
    }

    return '';
}

function generateInnerJoin(model: ER2CDS, relationship: Relationship): string {
    if (model.entities && model.entities.length > 0) {
        const firstEntity = model.entities[0];
        if (firstEntity.name === relationship.first?.target.ref?.name) {
            return expandToString`
                inner join ${relationship.second?.target.ref?.name} on ${generateJoinClause(relationship, relationship.second, relationship.first)}
            `;
        } else {
            return expandToString`
                inner join ${relationship.first?.target.ref?.name} on ${generateJoinClause(relationship, relationship.first, relationship.second)}
            `;
        }
    }

    return '';
}

function generateJoinClause(relationship: Relationship, source: RelationshipEntity | undefined, target: RelationshipEntity | undefined): string {
    return expandToString`
        ${source?.target.ref?.name}.${relationship.name} = ${target?.target.ref?.name}.${relationship.name}
    `;
}

function generateAttributes(model: ER2CDS) {
    if (model.entities) {
        let attributes: string[] = [];

        model.entities.forEach(e => {
            attributes.push(e.attributes.map(a => generateAttribute(e, a)).join(',\n'));
        });

        return attributes.join(',\n');
    }

    return '';
}

function generateAttribute(entity: Entity, attribute: Attribute) {
    return expandToString`
        ${entity.name}.${attribute.name} as ${entity.name}_${attribute.name}
    `;
}